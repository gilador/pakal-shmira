---
globs: *.ts,*.tsx,*.spec.ts,*.test.ts,tests/**/*
---

# Testing Standards

## Testing Strategy by File Type

### TypeScript Files (.ts)

- Use **unit testing** for business logic and service functions
- Test pure functions, calculations, and data transformations
- Mock external dependencies and focus on isolated functionality
- Use Jest or similar unit testing frameworks

### React Components (.tsx)

- Use **Playwright** for end-to-end testing
- Test user interactions, component behavior, and UI flows
- Focus on user scenarios rather than implementation details
- Test complete workflows from user perspective

## Test Implementation Policy

**IMPORTANT**: Do not implement tests immediately as part of change proposals. Always:

1. Propose the change/feature first
2. Wait for user approval
3. Only then implement the corresponding tests
4. This allows the user to review and approve the approach before test development

## Test Organization

- Group related tests using `describe` blocks by functionality
- Examples: "Staff Management", "Post Management"
- Use descriptive test names that explain what's being tested
- Example: "can add 2 users and edit both names to John Doe"

## Test Structure

- Follow the existing Playwright patterns in the codebase
- Use proper test data setup and teardown
- Include proper waits for UI elements with timeouts
- Test user flows, not just individual functions
- Use `data-testid` attributes for reliable element selection

## Test Naming Convention

- Use action-based naming: "can add...", "should display...", "allows user to..."
- Be specific about the expected outcome
- Focus on user behavior rather than implementation details

## Best Practices

- Test the happy path and edge cases
- Verify UI state changes after actions
- Use appropriate assertions for different scenarios
- Clean up test state between tests
